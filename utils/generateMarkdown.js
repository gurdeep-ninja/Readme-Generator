// function to generate markdown for README
function generateMarkdown(data) {

  // Initialise an empty array[] to store our formatted string
  let answers = [];

  // Initialise an array[] to create a markdown table of contents section
  // We will inject this into the answers[] array at position [2] - which is after the description.
  let contents = "## Table of Contents\n";

  // A custom flag used when creating the questions section of the README.md
  let questionsHeadingExists = false;

  // Loop through each of the answers to format the README.md contents based on the content.
  // i.e. If the user has not answered various questions, that corresponding section will not be added to the string returned.

  // Use a for in loop to iterate through the answers object generated by the inquirer module {}
  for (const key in data) {

    // Switch statement to format our README.md based on inquirer object{} key
    switch (key) {
      case "title":
        if (data[key] !== "") {

          // Push title to array
          answers.push(`# ${data[key]} ${getLicenseBadge(data.license)}\n`);

        }
        break;
      case "description":
        if (data[key] !== "") {

          // Push description to array
          let string = "";
          string += `## Description\n${data[key]}\n`;
          answers.push(string);

        };
        break;
      case "installation":
        if (data[key] !== "") {

          // Push install instructions to array
          let string = "";
          string += `## Installation\n${data[key]}\n`;
          answers.push(string);

          // add this section to the table of contents
          contents += "[Installation](#installation)<br>\n";
        };
        break;
      case "usage":
        if (data[key] !== "") {

          // Push usage to array          
          let string = "";
          string += `## Usage\n${data[key]}\n`;
          answers.push(string);

          // add this section to the table of contents
          contents += "[Usage](#usage)<br>\n";
        };
        break;
      case "license":
        if (data[key] !== "") {

          // Push  license to array          
          let string = "";
          string += `## License\n`
          string += `This app uses the following license: ${data[key]}\n`;
          answers.push(string);

          // add this section to the table of contents
          contents += "[License](#license)<br>\n";
        };
        break;
      case "contributing":
        if (data[key] !== "") {

          // Push contributing to array          
          let string = "";
          string += `## Contributing\n${data[key]}\n`;
          string += ``
          answers.push(string);

          // add this section to the table of contents
          contents += "[Contributing](#contributing)<br>\n";
        };
        break;
      case "tests":
        if (data[key] !== "") {

          // Push tests to array                    
          let string = "";
          string += `## Tests\n${data[key]}\n`;
          string += ``
          answers.push(string);

          // add this section to the table of contents
          contents += "[Tests](#tests)<br>\n";
        };
        break;
      case "github":
        if (data[key] !== "") {

          // Push users github details to array                    
          let string = "";
          string += `## Questions\n`
          string += `If you have any questions or would like to get in touch, please see my contact details below.<br>\n`;
          string += `GitHub: [${data[key]}](https://github.com/${data[key]})<br>\n`;
          answers.push(string);

          // add this section to the table of contents
          contents += "[Questions](#questions)<br>\n";

          // set to true the heading is not repeated when adding email to questions section.
          questionsHeadingExists = true;
        };
        break;
      case "email":
        if (data[key] !== "") {

          // Push users email details to array                    
          let string = "";

          // If the Questions heading is not present, create it
          if (!questionsHeadingExists) {
            string += `## Questions\n`;
            string += `If you have any questions or would like to get in touch, please see my contact details below.<br>\n`;

            // add this section to the table of contents            
            contents += "[Questions](#questions)<br>\n";
          }
          string += `Email: [${data[key]}](mailto:${data[key]})<br>\n`;
          answers.push(string);

        };
        break;
    }
  }
  // Add the Table of Contents (contents) to element 2 of the answers array (after description)
  answers.splice(2, 0, contents);

  // convert the answers array to a string
  const answersString = answers.join("");

  //return the completed README.md contents
  return  answersString;
}


// a function to get a license badge
function getLicenseBadge(license) {

  let badge = "";

  // Switch to select which license badge to include
  switch (license) {
    case "Apache License 2.0":
      badge = "![license](https://img.shields.io/badge/license-Apache%202.0-blue)";
      break;

    case "MIT License":
      badge = "![license](https://img.shields.io/badge/license-MIT-blue)";
      break;

    case "GNU General Public License v3.0":
      badge = "![license](https://img.shields.io/badge/license-GNU%203.0-blue)";
      break;

    case "Mozilla Public License 2.0":
      badge = "![license](https://img.shields.io/badge/license-Mozilla%202.0-blue)";
      break;

    default:
      badge = "";
  }

  // Return the badge markdown code
  return badge;
}

// node.js export this modules generateMarkdown function
module.exports = generateMarkdown;